import AsyncStorage from '@react-native-async-storage/async-storage';

// Inventory service for managing items
class InventoryService {
  constructor() {
    this.baseURL = 'https://your-api-endpoint.com/api'; // Replace with your actual API
  }

  // Get current user or create a default one
  getCurrentUser() {
    try {
      // Try to import authService dynamically to avoid dependency issues
      const authService = require('./authService').default;
      const user = authService.getCurrentUser();
      
      if (user && user.id) {
        return user;
      }
      
      // Fallback to a default user if authService doesn't work
      return { id: 'default_user' };
    } catch (error) {
      console.warn('AuthService not available, using default user:', error);
      // Fallback to a default user
      return { id: 'default_user' };
    }
  }

  // Get all inventory items for current user
  async getItems() {
    try {
      const user = this.getCurrentUser();
      if (!user || !user.id) {
        throw new Error('User not authenticated');
      }

      // For now, return mock data stored locally
      const storedItems = await AsyncStorage.getItem(`inventory_${user.id}`);
      
      if (storedItems) {
        const items = JSON.parse(storedItems);
        return {
          success: true,
          data: Array.isArray(items) ? items : [],
        };
      }

      // Return empty array if no items stored
      return {
        success: true,
        data: [],
      };
    } catch (error) {
      console.error('getItems error:', error);
      return {
        success: false,
        error: error.message || 'Failed to load items',
      };
    }
  }

  // Add new inventory item
  async addItem(itemData) {
    try {
      const user = this.getCurrentUser();
      if (!user || !user.id) {
        throw new Error('User not authenticated');
      }

      // Validate required fields
      const requiredFields = ['title', 'description', 'item_id', 'vendor', 'manufacture_date'];
      for (const field of requiredFields) {
        if (!itemData[field] || !itemData[field].toString().trim()) {
          throw new Error(`${field.replace('_', ' ')} is required`);
        }
      }

      // Get existing items
      const existingItems = await this.getItems();
      const items = existingItems.success ? existingItems.data : [];

      // Ensure items is an array
      const itemsArray = Array.isArray(items) ? items : [];

      // Check for duplicate item_id
      const isDuplicate = itemsArray.some(item => item.item_id === itemData.item_id.trim());
      if (isDuplicate) {
        throw new Error('Item ID already exists');
      }

      // Validate date format
      const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
      if (!dateRegex.test(itemData.manufacture_date)) {
        throw new Error('Manufacture date must be in YYYY-MM-DD format');
      }

      // Validate that the date is not in the future
      const manufactureDate = new Date(itemData.manufacture_date);
      const today = new Date();
      today.setHours(23, 59, 59, 999); // Set to end of today
      
      if (manufactureDate > today) {
        throw new Error('Manufacture date cannot be in the future');
      }

      // Validate that the date is valid
      if (isNaN(manufactureDate.getTime())) {
        throw new Error('Invalid manufacture date');
      }

      // Create new item
      const newItem = {
        id: Date.now(), // In real app, this would be generated by backend
        title: itemData.title.toString().trim(),
        description: itemData.description.toString().trim(),
        item_id: itemData.item_id.toString().trim(),
        vendor: itemData.vendor.toString().trim(),
        manufacture_date: itemData.manufacture_date,
        image_url: itemData.image_url || 'https://images.unsplash.com/photo-1586953208448-b95a79798f07?w=400&h=400&fit=crop', // Default image if none provided
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };

      // Add to items array
      itemsArray.unshift(newItem); // Add to beginning

      // Save to local storage
      await AsyncStorage.setItem(`inventory_${user.id}`, JSON.stringify(itemsArray));

      return {
        success: true,
        data: newItem,
      };
    } catch (error) {
      console.error('addItem error:', error);
      return {
        success: false,
        error: error.message || 'Failed to add item',
      };
    }
  }

  // Update inventory item
  async updateItem(itemId, updates) {
    try {
      const user = this.getCurrentUser();
      if (!user || !user.id) {
        throw new Error('User not authenticated');
      }

      // Get existing items
      const existingItems = await this.getItems();
      if (!existingItems.success) {
        throw new Error('Failed to load items');
      }

      const items = Array.isArray(existingItems.data) ? existingItems.data : [];
      const itemIndex = items.findIndex(item => item.id === itemId);

      if (itemIndex === -1) {
        throw new Error('Item not found');
      }

      // Validate item_id uniqueness if it's being updated
      if (updates.item_id && updates.item_id !== items[itemIndex].item_id) {
        const isDuplicate = items.some((item, index) => 
          index !== itemIndex && item.item_id === updates.item_id
        );
        if (isDuplicate) {
          throw new Error('Item ID already exists');
        }
      }

      // Validate date format if manufacture_date is being updated
      if (updates.manufacture_date) {
        const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
        if (!dateRegex.test(updates.manufacture_date)) {
          throw new Error('Manufacture date must be in YYYY-MM-DD format');
        }

        const manufactureDate = new Date(updates.manufacture_date);
        const today = new Date();
        today.setHours(23, 59, 59, 999);
        
        if (manufactureDate > today) {
          throw new Error('Manufacture date cannot be in the future');
        }

        if (isNaN(manufactureDate.getTime())) {
          throw new Error('Invalid manufacture date');
        }
      }

      // Clean up string fields
      const cleanUpdates = { ...updates };
      ['title', 'description', 'item_id', 'vendor'].forEach(field => {
        if (cleanUpdates[field] && typeof cleanUpdates[field] === 'string') {
          cleanUpdates[field] = cleanUpdates[field].trim();
        }
      });

      // Update item
      items[itemIndex] = {
        ...items[itemIndex],
        ...cleanUpdates,
        updated_at: new Date().toISOString(),
      };

      // Save back to storage
      await AsyncStorage.setItem(`inventory_${user.id}`, JSON.stringify(items));

      return {
        success: true,
        data: items[itemIndex],
      };
    } catch (error) {
      console.error('updateItem error:', error);
      return {
        success: false,
        error: error.message || 'Failed to update item',
      };
    }
  }

  // Delete inventory item
  async deleteItem(itemId) {
    try {
      const user = this.getCurrentUser();
      if (!user || !user.id) {
        throw new Error('User not authenticated');
      }

      // Get existing items
      const existingItems = await this.getItems();
      if (!existingItems.success) {
        throw new Error('Failed to load items');
      }

      const items = Array.isArray(existingItems.data) ? existingItems.data : [];
      const filteredItems = items.filter(item => item.id !== itemId);

      if (filteredItems.length === items.length) {
        throw new Error('Item not found');
      }

      // Save filtered items
      await AsyncStorage.setItem(`inventory_${user.id}`, JSON.stringify(filteredItems));

      return {
        success: true,
        message: 'Item deleted successfully',
      };
    } catch (error) {
      console.error('deleteItem error:', error);
      return {
        success: false,
        error: error.message || 'Failed to delete item',
      };
    }
  }

  // Search items
  async searchItems(query) {
    try {
      const result = await this.getItems();
      if (!result.success) {
        return result;
      }

      const items = Array.isArray(result.data) ? result.data : [];
      const searchQuery = query.toLowerCase();

      const filteredItems = items.filter(item =>
        item.title.toLowerCase().includes(searchQuery) ||
        item.item_id.toLowerCase().includes(searchQuery) ||
        item.vendor.toLowerCase().includes(searchQuery) ||
        item.description.toLowerCase().includes(searchQuery)
      );

      return {
        success: true,
        data: filteredItems,
      };
    } catch (error) {
      console.error('searchItems error:', error);
      return {
        success: false,
        error: error.message || 'Failed to search items',
      };
    }
  }

  // Get item by ID
  async getItemById(itemId) {
    try {
      const result = await this.getItems();
      if (!result.success) {
        return result;
      }

      const items = Array.isArray(result.data) ? result.data : [];
      const item = items.find(item => item.id === itemId);
      if (!item) {
        throw new Error('Item not found');
      }

      return {
        success: true,
        data: item,
      };
    } catch (error) {
      console.error('getItemById error:', error);
      return {
        success: false,
        error: error.message || 'Failed to get item',
      };
    }
  }

  // Get inventory statistics
  async getInventoryStats() {
    try {
      const result = await this.getItems();
      if (!result.success) {
        return result;
      }

      const items = Array.isArray(result.data) ? result.data : [];
      const vendors = [...new Set(items.map(item => item.vendor))];
      const totalItems = items.length;
      
      // Calculate items added this month
      const thisMonth = new Date();
      thisMonth.setDate(1);
      const itemsThisMonth = items.filter(item => 
        new Date(item.created_at) >= thisMonth
      ).length;

      return {
        success: true,
        data: {
          totalItems,
          totalVendors: vendors.length,
          itemsThisMonth,
          vendors,
        },
      };
    } catch (error) {
      console.error('getInventoryStats error:', error);
      return {
        success: false,
        error: error.message || 'Failed to get inventory stats',
      };
    }
  }

  // Validate item data
  validateItemData(itemData) {
    const errors = {};
    
    // Required field validation
    const requiredFields = {
      title: 'Title',
      description: 'Description', 
      item_id: 'Item ID',
      vendor: 'Vendor',
      manufacture_date: 'Manufacture Date'
    };

    Object.entries(requiredFields).forEach(([field, label]) => {
      if (!itemData[field] || !itemData[field].toString().trim()) {
        errors[field] = `${label} is required`;
      }
    });

    // Date format validation
    if (itemData.manufacture_date) {
      const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
      if (!dateRegex.test(itemData.manufacture_date)) {
        errors.manufacture_date = 'Date must be in YYYY-MM-DD format';
      } else {
        const manufactureDate = new Date(itemData.manufacture_date);
        const today = new Date();
        today.setHours(23, 59, 59, 999);
        
        if (manufactureDate > today) {
          errors.manufacture_date = 'Manufacture date cannot be in the future';
        }
        
        // Check if date is valid
        if (isNaN(manufactureDate.getTime())) {
          errors.manufacture_date = 'Invalid date';
        }
      }
    }

    // Item ID format validation (alphanumeric and some special chars)
    if (itemData.item_id) {
      const itemIdRegex = /^[A-Za-z0-9\-_]+$/;
      if (!itemIdRegex.test(itemData.item_id.toString().trim())) {
        errors.item_id = 'Item ID can only contain letters, numbers, hyphens, and underscores';
      }
    }

    return {
      isValid: Object.keys(errors).length === 0,
      errors
    };
  }

  // Seed initial data for demo
  async seedDemoData() {
    try {
      const user = this.getCurrentUser();
      if (!user || !user.id) {
        throw new Error('User not authenticated');
      }

      const demoItems = [
        {
          id: 1,
          item_id: 'ITM001',
          title: 'MacBook Pro 16"',
          description: 'High-performance laptop for development work',
          vendor: 'Apple Inc.',
          manufacture_date: '2023-10-15',
          image_url: 'https://images.unsplash.com/photo-1541807084-5c52b6b3adef?w=400&h=400&fit=crop',
          created_at: '2024-01-15T10:30:00Z',
          updated_at: '2024-01-15T10:30:00Z',
        },
        {
          id: 2,
          item_id: 'ITM002',
          title: 'iPhone 15 Pro',
          description: 'Latest smartphone with advanced camera system',
          vendor: 'Apple Inc.',
          manufacture_date: '2023-09-20',
          image_url: 'https://images.unsplash.com/photo-1592750475338-74b7b21085ab?w=400&h=400&fit=crop',
          created_at: '2024-01-16T14:20:00Z',
          updated_at: '2024-01-16T14:20:00Z',
        },
        {
          id: 3,
          item_id: 'ITM003',
          title: 'Dell UltraSharp Monitor',
          description: '32-inch 4K monitor for professional work',
          vendor: 'Dell Technologies',
          manufacture_date: '2023-11-08',
          image_url: 'https://images.unsplash.com/photo-1527443224154-c4a3942d3acf?w=400&h=400&fit=crop',
          created_at: '2024-01-17T09:15:00Z',
          updated_at: '2024-01-17T09:15:00Z',
        },
        {
          id: 4,
          item_id: 'ITM004',
          title: 'Sony WH-1000XM5',
          description: 'Premium noise-canceling headphones',
          vendor: 'Sony Corporation',
          manufacture_date: '2023-08-12',
          image_url: 'https://images.unsplash.com/photo-1583394838336-acd977736f90?w=400&h=400&fit=crop',
          created_at: '2024-01-18T16:45:00Z',
          updated_at: '2024-01-18T16:45:00Z',
        },
        {
          id: 5,
          item_id: 'ITM005',
          title: 'Canon EOS R5',
          description: 'Professional mirrorless camera',
          vendor: 'Canon Inc.',
          manufacture_date: '2023-07-25',
          image_url: 'https://images.unsplash.com/photo-1606983340126-99ab4feaa64a?w=400&h=400&fit=crop',
          created_at: '2024-01-19T11:30:00Z',
          updated_at: '2024-01-19T11:30:00Z',
        },
        {
          id: 6,
          item_id: 'ITM006',
          title: 'iPad Pro 12.9"',
          description: 'Powerful tablet for creative professionals',
          vendor: 'Apple Inc.',
          manufacture_date: '2023-06-10',
          image_url: 'https://images.unsplash.com/photo-1544244015-0df4b3ffc6b0?w=400&h=400&fit=crop',
          created_at: '2024-01-20T13:25:00Z',
          updated_at: '2024-01-20T13:25:00Z',
        },
      ];

      await AsyncStorage.setItem(`inventory_${user.id}`, JSON.stringify(demoItems));

      return {
        success: true,
        data: demoItems,
      };
    } catch (error) {
      console.error('seedDemoData error:', error);
      return {
        success: false,
        error: error.message || 'Failed to seed demo data',
      };
    }
  }

  // Clear all inventory data (for testing)
  async clearAllData() {
    try {
      const user = this.getCurrentUser();
      if (!user || !user.id) {
        throw new Error('User not authenticated');
      }

      await AsyncStorage.removeItem(`inventory_${user.id}`);

      return {
        success: true,
        message: 'All inventory data cleared',
      };
    } catch (error) {
      console.error('clearAllData error:', error);
      return {
        success: false,
        error: error.message || 'Failed to clear data',
      };
    }
  }

  // Generate next available item ID
  async generateNextItemId() {
    try {
      const result = await this.getItems();
      if (!result.success) {
        return {
          success: false,
          error: 'Failed to load existing items'
        };
      }

      const items = Array.isArray(result.data) ? result.data : [];
      let nextNumber = 1;

      // Find the highest existing number
      items.forEach(item => {
        const match = item.item_id.match(/^ITM(\d+)$/);
        if (match) {
          const num = parseInt(match[1], 10);
          if (num >= nextNumber) {
            nextNumber = num + 1;
          }
        }
      });

      const nextItemId = `ITM${nextNumber.toString().padStart(3, '0')}`;

      return {
        success: true,
        data: nextItemId
      };
    } catch (error) {
      console.error('generateNextItemId error:', error);
      return {
        success: false,
        error: error.message || 'Failed to generate item ID'
      };
    }
  }
}

// Export a singleton instance
export default new InventoryService();